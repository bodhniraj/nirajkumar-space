---
import AuraWallpaperGenerator from "../../components/AuraWallpaperGenerator.astro";
import Navigation from "../../components/Navigation.astro";
import "../../styles/global.css";
import "../../styles/aurawallpaper.css";
---

<html lang="en-US" data-theme="light" class="bg-white dark:bg-[#111111]">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/fav.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Aura Wallpaper Generator</title>
    <meta
      name="description"
      content="Use this aura wallpaper generator to create beautiful and aesthetic aura wallpapers."
    />
    <link
      rel="canonical"
      href="https://nirajkumar.space/tools/aurawallpaper/"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Gloria+Hallelujah&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        font-size: 16px;
      }

      body {
        font-family: "Inter", system-ui, sans-serif;
      }

      :root {
        --sel-bg: #dfdfdf;
        --sel-text: #555555;
      }

      .dark {
        --sel-bg: #242424;
        --sel-text: #bbbbbb;
      }

      *::selection {
        background: var(--sel-bg) !important;
        color: var(--sel-text) !important;
        text-shadow: none !important;
      }
      *::-moz-selection {
        background: var(--sel-bg) !important;
        color: var(--sel-text) !important;
        text-shadow: none !important;
      }
    </style>

    <!-- FOUC Removal -->
    <script is:inline>
      (function () {
        const theme = localStorage.theme;
        if (
          theme === "dark" ||
          (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
        ) {
          document.documentElement.classList.add("dark");
        } else {
          document.documentElement.classList.remove("dark");
        }
      })();
    </script>

    <!-- Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-W2389NHMDM"
    ></script>
    <script is:inline>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-W2389NHMDM");
    </script>
  </head>
  <body
    class="bg-white text-neutral-950 dark:bg-[#111111] dark:text-white min-h-screen w-full"
  >
    <Navigation />
    <AuraWallpaperGenerator />

    <script>
      import "../../scripts/darkmode.js";
    </script>

    <script is:inline>
      class AuraGenerator {
        constructor() {
          this.canvas = document.getElementById("auraCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.isAnimated = false;
          this.animationId = null;
          this.isCircular = true;
          this.colors = ["#5271ff", "#4ecdc4", "#34D399"];
          this.intensity = 1;
          this.size = 1;
          this.colorSchemes = [
            ["#ff6b6b", "#ff8e53", "#ff6b9d"],
            ["#4ecdc4", "#45b7d1", "#96ceb4"],
            ["#667eea", "#764ba2", "#f093fb"],
            ["#00ff87", "#60efff", "#ff0080"],
            ["#ffeaa7", "#fab1a0", "#e17055"],
            ["#fdcb6e", "#e17055", "#d63031"],
            ["#5B5150", "#E6EFC2", "#A2D5AC"],
            ["#2A4C65", "#F9B294", "#FD8A95"],
            ["#2A4C65", "#F9B294", "#FD8A95"],
            ["#215273", "#CFF4D2", "#55C595"],
            ["#22054F", "#28CFFD", "#9065D1"],
          ];

          this.setupCanvas();
          this.bindEvents();
          this.render();
          this.updateCSSDisplay();
        }

        setupCanvas() {
          const rect = this.canvas.getBoundingClientRect();
          this.canvas.width = 800;
          this.canvas.height = 600;
        }

        bindEvents() {
          // Color inputs
          document
            .getElementById("colorInputs")
            .addEventListener("change", (e) => {
              if (e.target.type === "color") {
                this.updateColors();
                this.render();
                this.updateCSSDisplay();
              }
            });

          // Add color button
          document.getElementById("addColor").addEventListener("click", () => {
            if (this.colors.length < 6) {
              this.addColorInput();
            }
          });

          // Sliders
          document
            .getElementById("intensity")
            .addEventListener("input", (e) => {
              this.intensity = parseFloat(e.target.value);
              this.render();
              this.updateCSSDisplay();
            });

          document.getElementById("size").addEventListener("input", (e) => {
            this.size = parseFloat(e.target.value);
            this.render();
            this.updateCSSDisplay();
          });

          // Shape toggle
          document
            .getElementById("circularBtn")
            .addEventListener("click", () => {
              this.isCircular = true;
              this.updateShapeButtons();
              this.render();
              this.updateCSSDisplay();
            });

          document.getElementById("linearBtn").addEventListener("click", () => {
            this.isCircular = false;
            this.updateShapeButtons();
            this.render();
            this.updateCSSDisplay();
          });

          // Animation toggle
          document
            .getElementById("toggleAnimation")
            .addEventListener("click", () => {
              this.toggleAnimation();
            });

          // Presets
          document.querySelectorAll(".preset-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              this.applyPreset(e.target.dataset.preset);
              this.updateCSSDisplay();
            });
          });

          // Actions
          document.getElementById("randomize").addEventListener("click", () => {
            this.randomize();
            this.updateCSSDisplay();
          });

          document.getElementById("download").addEventListener("click", () => {
            const format = document.querySelector(
              'input[name="format"]:checked'
            ).value;
            this.download(format);
          });

          // Copy CSS button
          document
            .getElementById("copyCSSBtn")
            .addEventListener("click", () => {
              this.copyCSS();
            });
        }

        updateColors() {
          const inputs = document.querySelectorAll(
            '#colorInputs input[type="color"]'
          );
          this.colors = Array.from(inputs).map((input) => input.value);
        }

        addColorInput() {
          const container = document.getElementById("colorInputs");
          const input = document.createElement("input");
          input.type = "color";
          input.className = "color-input";
          input.value = this.getRandomColor();

          const removeBtn = document.createElement("button");
          removeBtn.innerHTML = "Ã—";
          removeBtn.className =
            "absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs leading-none cursor-pointer";

          const wrapper = document.createElement("div");
          wrapper.className = "relative";
          wrapper.appendChild(input);
          wrapper.appendChild(removeBtn);

          removeBtn.addEventListener("click", () => {
            if (this.colors.length > 2) {
              wrapper.remove();
              this.updateColors();
              this.render();
              this.updateCSSDisplay();
            }
          });

          container.appendChild(wrapper);
          this.updateColors();
          this.render();
          this.updateCSSDisplay();
        }

        updateShapeButtons() {
          const circular = document.getElementById("circularBtn");
          const linear = document.getElementById("linearBtn");

          if (this.isCircular) {
            circular.classList.add("bg-white", "shadow-sm");
            linear.classList.remove("bg-white", "shadow-sm", "text-[#888888]");
          } else {
            linear.classList.add("bg-white", "shadow-sm", "text-[#888888]");
            circular.classList.remove("bg-white", "shadow-sm");
          }
        }

        toggleAnimation() {
          this.isAnimated = !this.isAnimated;
          const icon = document.getElementById("animationIcon");

          if (this.isAnimated) {
            icon.textContent = "ðŸŽžï¸";
            this.animate();
          } else {
            icon.textContent = "ðŸŽ¥";
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
            }
            this.render();
          }
        }

        animate() {
          if (!this.isAnimated) return;

          const time = Date.now() * 0.001;
          this.renderAura(time);
          this.animationId = requestAnimationFrame(() => this.animate());
        }

        render() {
          if (!this.isAnimated) {
            this.renderAura(0);
          }
        }

        renderAura(time = 0, canvasWidth = null, canvasHeight = null) {
          const width = canvasWidth || this.canvas.width;
          const height = canvasHeight || this.canvas.height;
          const centerX = width / 2;
          const centerY = height / 2;

          if (this.isCircular) {
            this.renderCircularAura(centerX, centerY, time, width, height);
          } else {
            this.renderLinearAura(time, width, height);
          }
        }

        renderCircularAura(centerX, centerY, time, canvasWidth, canvasHeight) {
          // Clear canvas
          this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);

          // Create base gradient background similar to linear
          const baseGradient = this.ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            Math.min(canvasWidth, canvasHeight) * 0.7
          );

          for (let i = 0; i < this.colors.length; i++) {
            const position = i / (this.colors.length - 1);
            const color = this.hexToRgb(this.colors[i]);
            const alpha = Math.max(0.3, this.intensity * 0.8);
            baseGradient.addColorStop(
              position,
              `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`
            );
          }

          this.ctx.fillStyle = baseGradient;
          this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);

          // Add multiple glow layers for depth
          const baseRadius =
            Math.min(canvasWidth, canvasHeight) * 0.25 * this.size;

          for (let i = 0; i < this.colors.length; i++) {
            const offset = time * 0.5 + (i * Math.PI * 2) / this.colors.length;
            const x =
              centerX + Math.cos(offset) * 40 * (this.isAnimated ? 1 : 0);
            const y =
              centerY + Math.sin(offset) * 25 * (this.isAnimated ? 1 : 0);
            const radius =
              baseRadius +
              Math.sin(time * 2 + i) * 15 * (this.isAnimated ? 1 : 0);

            // Create multiple layers for each color
            for (let layer = 0; layer < 3; layer++) {
              const layerRadius = radius * (1 + layer * 0.3);
              const gradient = this.ctx.createRadialGradient(
                x,
                y,
                0,
                x,
                y,
                layerRadius
              );

              const color = this.hexToRgb(this.colors[i]);
              const alpha = Math.max(
                0.15,
                (this.intensity * 0.6) / (layer + 1)
              );

              gradient.addColorStop(
                0,
                `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`
              );
              gradient.addColorStop(
                0.4,
                `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha * 0.5})`
              );
              gradient.addColorStop(
                1,
                `rgba(${color.r}, ${color.g}, ${color.b}, 0)`
              );

              this.ctx.globalCompositeOperation =
                layer === 0 ? "normal" : "screen";
              this.ctx.fillStyle = gradient;
              this.ctx.beginPath();
              this.ctx.arc(x, y, layerRadius, 0, Math.PI * 2);
              this.ctx.fill();
            }
          }

          this.ctx.globalCompositeOperation = "source-over";
        }

        renderLinearAura(time, canvasWidth, canvasHeight) {
          // Clear canvas
          this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);

          const gradient = this.ctx.createLinearGradient(
            0,
            0,
            canvasWidth,
            canvasHeight
          );

          for (let i = 0; i < this.colors.length; i++) {
            const position = i / (this.colors.length - 1);
            const color = this.hexToRgb(this.colors[i]);
            const alpha = Math.max(0.3, this.intensity * 0.9);
            gradient.addColorStop(
              position,
              `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`
            );
          }

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);

          // Add some blur effect with multiple layers
          for (let i = 0; i < 3; i++) {
            const layerGradient = this.ctx.createRadialGradient(
              canvasWidth / 2,
              canvasHeight / 2,
              0,
              canvasWidth / 2,
              canvasHeight / 2,
              Math.min(canvasWidth, canvasHeight) * 0.5 * this.size
            );

            const color = this.hexToRgb(this.colors[i % this.colors.length]);
            const alpha = Math.max(0.08, this.intensity * 0.15);
            layerGradient.addColorStop(
              0,
              `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`
            );
            layerGradient.addColorStop(
              1,
              `rgba(${color.r}, ${color.g}, ${color.b}, 0)`
            );

            this.ctx.globalCompositeOperation = "screen";
            this.ctx.fillStyle = layerGradient;
            this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          }

          this.ctx.globalCompositeOperation = "source-over";
        }

        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        getRandomColor() {
          return (
            "#" +
            Math.floor(Math.random() * 16777215)
              .toString(16)
              .padStart(6, "0")
          );
        }

        applyPreset(preset) {
          const presets = {
            sunset: ["#ff6b6b", "#ff8e53", "#ff6b9d"],
            ocean: ["#4ecdc4", "#45b7d1", "#96ceb4"],
            galaxy: ["#667eea", "#764ba2", "#f093fb"],
            neon: ["#00ff87", "#60efff", "#ff0080"],
            pastel: ["#ffeaa7", "#fab1a0", "#e17055"],
            warm: ["#fdcb6e", "#e17055", "#d63031"],
          };

          if (presets[preset]) {
            this.colors = presets[preset];
            this.updateColorInputs();
            this.render();
          }
        }

        updateColorInputs() {
          const container = document.getElementById("colorInputs");
          container.innerHTML = "";

          this.colors.forEach((color, index) => {
            const input = document.createElement("input");
            input.type = "color";
            input.className = "color-input";
            input.value = color;
            container.appendChild(input);
          });
        }

        randomize() {
          // Select random color scheme from predefined list
          const randomScheme =
            this.colorSchemes[
              Math.floor(Math.random() * this.colorSchemes.length)
            ];
          this.colors = [...randomScheme]; // Copy the array

          this.intensity = 0.5 + Math.random() * 1.5;
          this.size = 0.5 + Math.random() * 1.5;
          this.isCircular = Math.random() > 0.5;

          document.getElementById("intensity").value = this.intensity;
          document.getElementById("size").value = this.size;

          this.updateColorInputs();
          this.updateShapeButtons();
          this.render();
        }

        download(format) {
          const resolution = document.getElementById("resolution").value;
          const [width, height] = resolution.split("x").map(Number);

          // Create temporary canvas for high-resolution export
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;
          const tempCtx = tempCanvas.getContext("2d");

          // Store original canvas and context
          const originalCanvas = this.canvas;
          const originalCtx = this.ctx;

          // Switch to temp canvas
          this.canvas = tempCanvas;
          this.ctx = tempCtx;

          // Fill with black background first
          this.ctx.fillStyle = "#000000";
          this.ctx.fillRect(0, 0, width, height);

          // Render the aura at high resolution
          this.renderAura(0, width, height);

          // Create download link
          const link = document.createElement("a");
          link.download = `aura-background-${width}x${height}.${format}`;

          // Set appropriate MIME type and quality
          if (format === "png") {
            link.href = tempCanvas.toDataURL("image/png");
          } else if (format === "jpeg") {
            link.href = tempCanvas.toDataURL("image/jpeg", 0.95);
          } else if (format === "webp") {
            link.href = tempCanvas.toDataURL("image/webp", 0.95);
          }

          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Restore original canvas and context
          this.canvas = originalCanvas;
          this.ctx = originalCtx;
        }

        updateCSSDisplay() {
          let css;
          if (this.isCircular) {
            css = `background: radial-gradient(circle at center, ${this.colors.join(", ")});`;
          } else {
            css = `background: linear-gradient(135deg, ${this.colors.join(", ")});`;
          }

          document.getElementById("cssOutput").textContent = css;
        }

        copyCSS() {
          const css = document.getElementById("cssOutput").textContent;
          navigator.clipboard
            .writeText(css)
            .then(() => {
              const btn = document.getElementById("copyCSSBtn");
              const originalText = btn.textContent;
              btn.textContent = "Copied!";
              btn.classList.add("bg-green-100", "text-green-700");
              btn.classList.remove("bg-blue-100", "text-blue-700");

              setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove("bg-green-100", "text-green-700");
                btn.classList.add("bg-blue-100", "text-blue-700");
              }, 2000);
            })
            .catch(() => {
              prompt("Copy this CSS:", css);
            });
        }
      }

      // Initialize the app
      document.addEventListener("DOMContentLoaded", () => {
        new AuraGenerator();
      });
    </script>
  </body>
</html>
